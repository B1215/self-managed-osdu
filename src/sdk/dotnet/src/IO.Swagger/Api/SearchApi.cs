/* 
 * self-managed-osdu
 *
 * Rest API Documentation for Self Managed OSDU
 *
 * OpenAPI spec version: 0.11.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns></returns>
        void DeleteIndex (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteIndexWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>string</returns>
        string GetKindSchema (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetKindSchemaWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Queries the index for the specified kind using the input query string.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>SearchQueryResponse</returns>
        SearchQueryResponse QueryRecords (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Queries the index for the specified kind using the input query string.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of SearchQueryResponse</returns>
        ApiResponse<SearchQueryResponse> QueryRecordsWithHttpInfo (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Query the index using cursor and optionally return only requested fields.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>SearchCursorQueryResponse</returns>
        SearchCursorQueryResponse QueryWithCursor (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of SearchCursorQueryResponse</returns>
        ApiResponse<SearchCursorQueryResponse> QueryWithCursorWithHttpInfo (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteIndexAsync (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteIndexAsyncWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetKindSchemaAsync (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;.
        /// </summary>
        /// <remarks>
        /// The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetKindSchemaAsyncWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Queries the index for the specified kind using the input query string.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of SearchQueryResponse</returns>
        System.Threading.Tasks.Task<SearchQueryResponse> QueryRecordsAsync (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Queries the index for the specified kind using the input query string.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (SearchQueryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchQueryResponse>> QueryRecordsAsyncWithHttpInfo (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null);
        /// <summary>
        /// Query the index using cursor and optionally return only requested fields.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of SearchCursorQueryResponse</returns>
        System.Threading.Tasks.Task<SearchCursorQueryResponse> QueryWithCursorAsync (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null);

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields.
        /// </summary>
        /// <remarks>
        /// The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (SearchCursorQueryResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchCursorQueryResponse>> QueryWithCursorAsyncWithHttpInfo (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SearchApi : ISearchApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SearchApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;. The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns></returns>
        public void DeleteIndex (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
             DeleteIndexWithHttpInfo(oSDUAccountId, kind, oSDUOnBehalfOf);
        }

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;. The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteIndexWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->DeleteIndex");
            // verify the required parameter 'kind' is set
            if (kind == null)
                throw new ApiException(400, "Missing required parameter 'kind' when calling SearchApi->DeleteIndex");

            var localVarPath = "/api/search/v2/index/{kind}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (kind != null) localVarPathParams.Add("kind", this.Configuration.ApiClient.ParameterToString(kind)); // path parameter
            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;. The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteIndexAsync (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
             await DeleteIndexAsyncWithHttpInfo(oSDUAccountId, kind, oSDUOnBehalfOf);

        }

        /// <summary>
        /// Deletes all documents from index for given &#39;kind&#39;. The API can be used  to purge all indexed documents for a kind. Required access level to use this API is service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteIndexAsyncWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->DeleteIndex");
            // verify the required parameter 'kind' is set
            if (kind == null)
                throw new ApiException(400, "Missing required parameter 'kind' when calling SearchApi->DeleteIndex");

            var localVarPath = "/api/search/v2/index/{kind}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (kind != null) localVarPathParams.Add("kind", this.Configuration.ApiClient.ParameterToString(kind)); // path parameter
            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;. The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>string</returns>
        public string GetKindSchema (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
             ApiResponse<string> localVarResponse = GetKindSchemaWithHttpInfo(oSDUAccountId, kind, oSDUOnBehalfOf);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;. The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > GetKindSchemaWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->GetKindSchema");
            // verify the required parameter 'kind' is set
            if (kind == null)
                throw new ApiException(400, "Missing required parameter 'kind' when calling SearchApi->GetKindSchema");

            var localVarPath = "/api/search/v2/index/schema/{kind}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (kind != null) localVarPathParams.Add("kind", this.Configuration.ApiClient.ParameterToString(kind)); // path parameter
            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetKindSchema", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;. The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetKindSchemaAsync (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
             ApiResponse<string> localVarResponse = await GetKindSchemaAsyncWithHttpInfo(oSDUAccountId, kind, oSDUOnBehalfOf);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Returns the index schema for given &#39;kind&#39;. The API returns the schema for a given kind which is used find what attributes are indexed and their respective data types (at index time). Required access levels to use this API are service.search.user, service.search.admin
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="kind">Kind of the record.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> GetKindSchemaAsyncWithHttpInfo (string oSDUAccountId, string kind, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->GetKindSchema");
            // verify the required parameter 'kind' is set
            if (kind == null)
                throw new ApiException(400, "Missing required parameter 'kind' when calling SearchApi->GetKindSchema");

            var localVarPath = "/api/search/v2/index/schema/{kind}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (kind != null) localVarPathParams.Add("kind", this.Configuration.ApiClient.ParameterToString(kind)); // path parameter
            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetKindSchema", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Queries the index for the specified kind using the input query string. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>SearchQueryResponse</returns>
        public SearchQueryResponse QueryRecords (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null)
        {
             ApiResponse<SearchQueryResponse> localVarResponse = QueryRecordsWithHttpInfo(oSDUAccountId, body, oSDUOnBehalfOf);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Queries the index for the specified kind using the input query string. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of SearchQueryResponse</returns>
        public ApiResponse< SearchQueryResponse > QueryRecordsWithHttpInfo (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->QueryRecords");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SearchApi->QueryRecords");

            var localVarPath = "/api/search/v2/query";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SearchQueryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SearchQueryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SearchQueryResponse)));
        }

        /// <summary>
        /// Queries the index for the specified kind using the input query string. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of SearchQueryResponse</returns>
        public async System.Threading.Tasks.Task<SearchQueryResponse> QueryRecordsAsync (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null)
        {
             ApiResponse<SearchQueryResponse> localVarResponse = await QueryRecordsAsyncWithHttpInfo(oSDUAccountId, body, oSDUOnBehalfOf);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Queries the index for the specified kind using the input query string. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (SearchQueryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SearchQueryResponse>> QueryRecordsAsyncWithHttpInfo (string oSDUAccountId, SearchQueryRequest body, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->QueryRecords");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SearchApi->QueryRecords");

            var localVarPath = "/api/search/v2/query";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SearchQueryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SearchQueryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SearchQueryResponse)));
        }

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>SearchCursorQueryResponse</returns>
        public SearchCursorQueryResponse QueryWithCursor (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null)
        {
             ApiResponse<SearchCursorQueryResponse> localVarResponse = QueryWithCursorWithHttpInfo(oSDUAccountId, body, oSDUOnBehalfOf);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>ApiResponse of SearchCursorQueryResponse</returns>
        public ApiResponse< SearchCursorQueryResponse > QueryWithCursorWithHttpInfo (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->QueryWithCursor");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SearchApi->QueryWithCursor");

            var localVarPath = "/api/search/v2/query_with_cursor";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryWithCursor", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SearchCursorQueryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SearchCursorQueryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SearchCursorQueryResponse)));
        }

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of SearchCursorQueryResponse</returns>
        public async System.Threading.Tasks.Task<SearchCursorQueryResponse> QueryWithCursorAsync (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null)
        {
             ApiResponse<SearchCursorQueryResponse> localVarResponse = await QueryWithCursorAsyncWithHttpInfo(oSDUAccountId, body, oSDUOnBehalfOf);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query the index using cursor and optionally return only requested fields. The API supports full text search on string fields, range queries on date, numeric or string fields, along with geo-spatial search. Required access levels to use this API are service.search.user, service.search.admin. In addition, users must be a member of data groups to access the data. It can be used to retrieve large numbers of results (or even all results) from a single search request, in much the same way as you would use a cursor on a traditional database.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="oSDUAccountId">Account ID is the active OSDU account (OSDU account or customer&#39;s account) which the users choose to use with the Search API.</param>
        /// <param name="body">Specifies the API parameters. The only required parameter is the kind which needs to be formatted correctly.</param>
        /// <param name="oSDUOnBehalfOf">On behalf email or token is the token/email of the original user making the call. For now, only email is supported but eventually, primary usage will be token. (optional)</param>
        /// <returns>Task of ApiResponse (SearchCursorQueryResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SearchCursorQueryResponse>> QueryWithCursorAsyncWithHttpInfo (string oSDUAccountId, SearchCursorQueryRequest body, string oSDUOnBehalfOf = null)
        {
            // verify the required parameter 'oSDUAccountId' is set
            if (oSDUAccountId == null)
                throw new ApiException(400, "Missing required parameter 'oSDUAccountId' when calling SearchApi->QueryWithCursor");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling SearchApi->QueryWithCursor");

            var localVarPath = "/api/search/v2/query_with_cursor";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (oSDUAccountId != null) localVarHeaderParams.Add("OSDU-Account-Id", this.Configuration.ApiClient.ParameterToString(oSDUAccountId)); // header parameter
            if (oSDUOnBehalfOf != null) localVarHeaderParams.Add("OSDU-On-Behalf-Of", this.Configuration.ApiClient.ParameterToString(oSDUOnBehalfOf)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // authentication (Bearer) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("QueryWithCursor", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SearchCursorQueryResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SearchCursorQueryResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SearchCursorQueryResponse)));
        }

    }
}
